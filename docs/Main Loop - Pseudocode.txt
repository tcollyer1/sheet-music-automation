float samples[WINDOW_SIZE]; // Sample size
float imaginary[WINDOW_SIZE]; // For converting FFT input to a complex number
float window[WINDOW_SIZE];

...

applyWindow(float* samples)
{
	hannFunction(samples, window);
}

...

int main()
{
	float samples[WINDOW_SIZE];
	float window[WINDOW_SIZE];

	float max, current, peakBinNumber, frequency = 0.0;

	float binSize = SAMPLE_RATE / WINDOW_SIZE;		

	while (streamOpen):
		readSamples(samples);

		for (i=0; i<WINDOW_SIZE; i++):
			samples[i] = lowPass(samples[i]);

		// Remove artefacts generated by non-periodic signal (spectral leakage)
		applyHannWindow(samples);
	
		// Acquire both real and imaginary outputs
		FFT(samples, imaginary);

		// WINDOW_SIZE / 2 represents the outputs we want - the second half are the mirrored
		// outputs in a complex-to-complex FFT
		for (i=0; i<WINDOW_SIZE/2; i++):
			// Calculate magnitude - sqrt(real * real + imag * imag)
			current = sqrt((samples[i] * samples[i]) + (imaginary[i] * imaginary[i]));
			if (current > max) then max = current, peakBinNumber = i;

		// Get the frequency of the bin with the max magnitude
		frequency = peakBinNumber * binSize;

		...		

	return 0;
}